% coding: utf-8
% --------------------------------------------------------------------------------------------------
% "Синтез оптимального стохастического управления", 2011 год
% --------------------------------------------------------------------------------------------------
\chapter{Пример решения типовой задачи}
% ==============================================================================================
\renewcommand{\optU}{  \optimum{\m{u}}  } % оптимальное управление
\renewcommand{\funcF}{ \calf{F}         } % множество F

\renewcommand{\optF}{  \optimum{\funcF} } % оптимальный критерий качества
\newcommand{\funcS}{   \calf{S}         } % второстепенный критерий качества
% ==============================================================================================



% **********************************************************************************************
\section{Постановка задачи}
% **********************************************************************************************



Рассмотрим полученные в разделах 2 и 3 результаты, применим их к конкретной задаче.

Пускай стоит задача вывода на орбиту искусственного спутника. В подобных задачах ракета-носитель должна следовать по номинальной траектории. Но из-за нестационарности параметров, этого не будет. Для коррекции небольших отклонений относительно заданной траектории можно, например, линеаризовать динамику ракеты-носителя относительно заданной траектории. После выбора критерия, можно приступать к расчетам в соответствии с методиками этого раздела.

Динамику линеаризованного контура наведения ракеты можно выразить в следующей форме:

\beq{eq:4/1/1}
	\eqsystem{
		\dot{x}_1 &= x_2 \text{,} \\
		\dot{x}_2 &= \frac{k_1}{k_2 - t} x_3 \text{,} \\
		\dot{x}_3 &= u \text{.}
	}
\eeq

где $0 \leqslant t \leqslant T$ и

\begin{description}
	\item[$x_1$]~--- боковое отклонение от номинальной траектории;
	\item[$x_2$]~--- скорость этого отклонения;
	\item[$x_3$]~--- угол направления вектора тяги.
\end{description}

Зависимость между боковой тягой и боковым ускорением нестационарна и определяется коэффициентом $k_1 / (k_2 - t)$, который учитывает потерю массы при действии тяги. Интегрируемая связь между $x_3$ и $u$ представляет собой линеаризованное уравнение привода.

Если исходить из предположения о возможности точного измерения $x_1(t)$, $x_2(t)$ и $x_3(t)$, то можно разработать такую систему управления с обратной связью, чтобы обеспечить оптимальное наведение ракеты, удовлетворив при этом заданному показателю качества. Предположим, что используется функционал вида

\beq{eq:4/1/2}
	\funcF = \frac{1}{2} \int\limits_0^T \bigl( \m{x}^T(\tau)\m{Q}(\tau)\m{x}(\tau) + ru^2(t) \bigr)\,d\tau \text{.}
\eeq

Систему~\ref{eq:4/1/1} можно представить в обозначениях раздела 2.2, а именно в виде системы $\m{x}(t) = \m{A}(t)\m{x}(t) + \m{B}(t)\m{u}(t)$. Это возможно, поскольку матрицы $\m{A}$ и $\m{B}$ выражаются как

\beqarr
	\lbl{eq:4/1/3}
		\m{A}(t) = \matr{
			0 & 1 & 0 \\
			0 & 0 & \frac{k_1}{k_2-t} \\
			0 & 0 & 0		
		} \text{;} \\
	\lbl{eq:4/1/4}
		\m{B}(t) = \m{b} = \matr{
			0 \\ 0 \\ 1		
		} \text{.}
\eeqarr

Иными словами, задача выражается как задача из раздела 2.2 с критерием качества~\vref{eq:2/2/11}. Как было показано, для ее решения, необходимо получить матрицу $\m{P}(t)$ с граничным условием $\m{P}(T) = \m{0}$. Как было показано ранее, оптимальное уравнение в данном случае равно

\beq{eq:4/1/5}
	\optU(t) = -\frac{1}{r}\m{B}(t)^T\m{P}(t)\m{x}(t) = -\frac{1}{r}\m{b}^T\m{P}(t)\m{x}(t) \text{.}
\eeq

С другой стороны, так как

\beq{eq:4/1/6}
	\m{P}(t) = \matr{
		p_{11}(t) & p_{21}(t) & p_{31}(t) \\
		p_{12}(t) & p_{22}(t) & p_{32}(t) \\
		p_{13}(t) & p_{23}(t) & p_{33}(t) \\
	} \text{,}
\eeq

то учитывая~\ref{eq:4/1/4} и~\ref{eq:4/1/5}, получаем, что

\beq{eq:4/1/7}
	\optU(t) = -\frac{1}{r} \matr{ p_{13}(t) & p_{23}(t) & p_{33}(t) } \m{x}(t) \text{.}
\eeq

\br

Учтем теперь влияние атмосферы на движение ракеты. Скорость ветра $\m{V}$, вообще говоря, является векторной случайной функцией, состоящей из координат точки атмосферы и времени

\beq{eq:4/1/8}
	\m{V} = \m{V}(p, q, z, t) \text{,}
\eeq

где $p$, $q$, $z$~--- пространственные координаты\footnote{Традиционное обозначение координат как $x_0$, $y_0$ и $z_0$ в работе не используется, поскольку эти символы уже заняты.}, а $t$~--- время. Иными словами, скорость ветра является векторным случайным полем.

Величина $\m{V}$ может быть представлена в виде суммы среднего вектора $\bar{\m{V}}$ и центрированной составляющей $\m{V}_{\text{сл}}$:

\beq{eq:4/1/9}
	\m{V} = \bar{\m{V}} + \m{V}_{\text{сл}} (p, q, z, t) \text{.}
\eeq

Под $\bar{\m{V}}$ понимается среднее по некоторому интервалу времени значение вектора ветра в рассматриваемой точке. Наличие случайной составляющей $\m{V}_{\text{сл}}$ означает турбулентность атмосферы.

Вообще говоря, колебания или вариации скорости ветра в атмосфере имеют очень широкий спектр, начиная от годовых изменений и кончая пульсациями с частотой в десятки и даже сотни герц, вызванных самыми мелкими вихрями вблизи поверхности земли или даже самого летательного аппарата. Однако для задач управления движением весьма низкочастотные вариации не имеют значения\cite{KRASOVSKY}, и усреднение в формуле~\ref{eq:4/1/9} может осуществляться по интервалу, измеряемому минутами.

Если все статистические характеристики случайной функции $\m{V}$, вычисляемые для произвольной точки $(p_0, q_0, z_0)$, не зависят от этой точки, то есть одинаковы для рассматриваемого пространства, то турбулентность называется \emph{однородной}. Некоторые статистические характеристики, такие как корреляционные функции или законы совместного распределения вероятностей, вычисляются для двух или большего числа точек рассматриваемого пространства. Если эти статистические характеристики не меняются при параллельных переносах, вращениях и зеркальных отражениях этой системы, то турбулентность называется \emph{изотропной}. Иными словами, поле турбулентности изотропно, если в нем нельзя выделить никакого преимущественного направления.

Принято полагать, что анизотропность турбулентности атмосферы вызыается преимущественно рельефом местности. Для высот, больших 1000 метров, турбулентность атмосферы считают изотропной. При рассмотрении движения ракеты скорость воздуха можно считать случайной функцией не трех, а только одной пространственной координаты $p$, отсчитываемой вдоль траектории полета:

\beq{eq:4/1/10}
	\m{V}_{\text{сл}} = \m{V}_{\text{сл}} (p, t) \text{.}
\eeq

Объясняется это тем, что на движение ракеты как твердого тела слабо влияют высокочастотные составляющие\cite{KRASOVSKY}, создаваемые вихрями меньших размера самой ракеты. Поэтому скорость ветра в пределах контуров тела приближенно можно считать одинаковой. Для аэроупругого летательного аппарата обычно необходимо учитывать более высокочастотные составляющие воздействий турбулентной атмосферы, следовательно уравнение~\ref{eq:4/1/10} не срабатывает.

Возвращаясь к привычным обозначениям, можно считать, что случайная составляющая зависит лишь от времени $t$ и бокового отклонения от номинальной траектории $x_1$:

\beq{eq:4/1/11}
	\m{V}_{\text{сл}} = \m{V}_{\text{сл}} \bigl(x_1(t), t \bigr) \text{.}
\eeq

Впрочем, при достаточно большой скорости самолета вторым аргументом можно пренебречь, полагая

\beq{eq:4/1/12}
	V_{\text{сл}} = \m{V}_{\text{сл}} \bigl(x_1(t) \bigr) \text{.}
\eeq

Это означает, что распределение ветра в пространстве считается как бы <<замороженным>> и зависимость от времени получается за счет того, что самолет пронизывает это распределение. Данное допущение носит название \emph{гипотезы Тейлора}\cite{MONIN}. Гипотеза Тейлора подвергалась экспериментальной проверке неоднократно, противоречащих результатов получено не было.

Скорость ветра, очевидно, влияет на скорость отклонения ракеты с траектории, следовательно система~\vref{eq:4/1/1} может быть переписана с поправкой на турбулентность атмосферы следующим образом:

\beq{eq:4/1/13}
	\eqsystem{
		\dot{x}_1 &= x_2 \text{,} \\
		\dot{x}_2 &= \frac{k_1}{k_2 - t} x_3 + V(x_1) \text{,} \\
		\dot{x}_3 &= u \text{.}
	}
\eeq

Будем считать, что пространство изотропно, а скорость ракеты достаточна для того, чтобы можно было воспользоваться гипотезой Тейлора. Не нарушая общности, можно полагать, средний по интервалу вектор $\m{V}$ равен нулевому. Иными словами, мы предполагаем такую ситуацию, когда нет перепадов давления, и, следовательно, нет постоянного ветра (либо скорость ветра пренебрежительно мала по сравнению со скоростью ракеты), лишь некоторые атмосферные шумы. Небольшие естественные атмосферные воздействия можно представить в виде белого шума, который моделируется стандартным винеровским процессом, определение которому дано на странице~\pageref{df:6}.

Таким образом, систему~\ref{eq:4/1/13} можно представить в виде следующего процесса Ито:

\beq{eq:4/1/14}
	\eqsystem{
		\dot{x}_1 &= x_2 \text{,} \\
		\dot{x}_2 &= \frac{k_1}{k_2 - t} x_3 + \xi(t) \text{,} \\
		\dot{x}_3 &= u \text{.}
	}
\eeq

Функция $\frac{k_1}{k_2 - t} x_3$ в уравнении для $\dot{x}_2$ будет определять коэффицент сноса, а случайная функция $\xi(t)$~--- коэффицент диффузии.

Задачу~\ref{eq:4/1/14} можно моделировать следующим образом

\beq{eq:4/1/15}
	\eqsystem{
		\dot{x}_1 &= x_2 \text{,} \\
		\dot{x}_2 &= \frac{k_1}{k_2 - t} x_3 + \xi_t \text{,} \\
		\dot{x}_3 &= u \text{.}
	}
\eeq

где $\{\xi_t\}_{t=0}^\infty$~--- последовательность независимых одинаково распределенных случайных величин с распределением Гаусса. Известно\cite{ARKHIPOV}, что в этом случае случайный процесс~\ref{eq:4/1/15} будет слабо сходиться к процессу~\ref{eq:4/1/15}.



% **********************************************************************************************
\section{Исследование и анализ алгоритмов решения поставленной задачи}
% **********************************************************************************************



Рассмотрим систему~\ref{eq:4/1/15} c критерием качества~\ref{eq:4/1/2}.

Для того, чтобы получить матрицу $\m{P}(t)$ требуется решить уравнение~\vref{eq:2/2/7}. Эту задачу, вследствие нелинейности системы нужно решать численно, двигаясь в обратном времени от $t=T$ с граничным условием $\m{P}(T) = \m{0}$.

Таким образом, можно сформулировать первый алгоритм решения задачи:

\balgo{alg:1}
	\benum
		\item
			Для заданных $T$, $r$, $\m{Q}(t)$ требуется решить матричное дифференциальное уравнение~\ref{eq:2/2/7} в обратном времени с граничным условием $\m{P}(T) = \m{0}$. Таким образом, получим траекторию $\m{P}(t)$, где $0 \leqslant t \leqslant T$;
			
		\item
			Пользуясь формулой~\ref{eq:4/1/7} получаем оптимальное управление $\optU(t)$ на интервале $0 \leqslant t \leqslant T$ в каждый момент времени $t$\footnote{Обратим внимание, что таким образом синтезируется управление с обратной связью, следовательно необходимо знать точные значения каждой переменной состояния из вектора $\m{x}(t)$ в рассматриваемый момент времени.}. 
	\eenum
\ealgo

\br

Рассмотрим теперь случай, когда система стационарна. Как было показано ранее, при $T \to \infty$, уравнение~\vref{eq:2/2/7} сводится к нелинейному алгебраическому уравнению Риккати~\vref{eq:2/2/10}. Остальные действия остаются прежними. Формула~\ref{eq:4/1/7} также преобразуется с учетом этой особенности:

\beq{eq:4/2/2}
	\optU(t) = -\frac{1}{r} \matr{ p_{13} & p_{23} & p_{33} } \m{x}(t) \text{.}
\eeq

Следовательно, можно построить новый алгоритм, берущий за основу алгоритм~\ref{alg:1}.

\balgo{alg:2}
	\benum
		\item
			Для заданных $T$, $r$, $\m{Q}$ требуется решить матричное алгебраическое уравнение~\ref{eq:2/2/10}. Таким образом, получим матрицу с постоянными коэффициентами $\m{P}$ для всех $0 \leqslant t \leqslant T$;
			
		\item
			Пользуясь формулой~\ref{eq:4/2/2} получаем оптимальное управление $\optU(t)$ на интервале $0 \leqslant t \leqslant T$ в каждый момент времени $t$.
	\eenum
\ealgo

Опять же, стоит обратить внимание на то, что таким образом синтезируется управление с обратной связью, следовательно необходимо знать точные значения каждой переменной состояния из вектора $\m{x}(t)$ в рассматриваемый момент времени.

\br

Метод Беллмана, неявно лежащий в основе вышеприведенных алгоритмов, в некотором смысле аддитивен. Уравнения Беллмана позволяют найти оптимальное управление не только в целом, но и на конкретном шаге. В основной теореме динамического программирования, доказанной Беллманом утверждается, что управление, построенное таким образом, будет оптимальным. Действительно, одним из следствий уравнения~\vref{eq:2/1/17} является тот факт, что в любой момент времени величина критерия должна быть минимальной. Следовательно, если разбить задачу динамического программирования на несколько частей, прямо следующих друг за другом, причем состояние, в котором система оказалась в конце предыдущей части, будет начальным состоянием последующей, то в результате траектория динамики системы окажется такой, при которой критерий качества будет минимальным, а полученное управление~--- оптимальным.

Из уравнений~\ref{eq:2/1/3} и~\ref{eq:2/1/4}, а также из утверждения~\vref{statement:1} следует, что такое кусочное управление будет эквивалентно оптимальному. Возможна ситуация, когда управление, полученное таким образом, будет отличаться от управления, полученного из уравнений~\ref{eq:2/2/8} и~\vref{eq:2/2/9}, однако ввиду того, что значения критериев равны (оба уравнения доставляют минимум критерию качества~\vref{eq:2/2/1}), оба управления будут являться оптимальными. Иными словами, уравнения Беллмана позволяют получить оптимальное управление, но из них, конечно же, никоим образом не следует единственность минимума критерия качества.

Из этих рассуждений следует, что не имеет большого значения то, каким способом получается оптимальное управление в случае детерминированной системы~\vref{eq:4/1/1}, однако различия в подходах имеют смысл в случае стохастической системы~\vref{eq:4/1/14}. В сильно зашумленных системах, где диффузия оказывает большое влияние на динамику траекторий, дробя процесс вычисления траектории на несколько, можно построить адаптивный алгоритм, который будет учитывать не только параметры системы, но и степень отклонения от намеченной траектории. Иными словами, адаптивный характер алгоритма должен минимизировать влияние тех факторов, которые прямо контролировать невозможно, либо слишком сложно и затратно.

Отметим тот факт, что оба предложеных ранее алгоритма рассчитывают управление сразу на весь временной интервал наблюдений, после чего ракета наводится программно, без учета внешних воздействий. Предлагается рассчитывать управление поэтапно.

\br

Основная идея предлагаемого адаптивного управления заключается в следующем. Разобъем временной промежуток наблюдений $0 \leqslant t \leqslant T$ на $n+1$ равную часть: $0 = t_0 \leqslant t_1 \leqslant t_2 \leqslant \ldots \leqslant t_{n} = T$ ($t_{i+1}-t_i = t_{j+1}-t_j$ для всех $i, j < n$). Дальше, следуя алгоритмам~\ref{alg:1} и~\ref{alg:2}, синтезируем управление на всем интервале наблюдений, однако управление используем лишь на первом временном промежутке $[t_0, t_1)$. В момент времени $t_1$ происходит проверка эффективности проведенного управления с помощью некоторого заранее определенного вторичного критериия качества $\funcS(\m{x}, t_0, t_1)$ по заданному правилу.

Если сравнение показало, что управление не столь эффективно, как бы этого хотелось, то синтезированное ранее управление отбрасывается, и задача решается заново, но уже для промежутка $t_1 \leqslant t \leqslant T$, однако изначальное деление на интервалы сохраняется.

Если же сравнение управления показало его эффективность на первом интервале, то используется синтезированное ранее управление. В обоих случаях, в конце промежутка $[t_1, t_2)$, в момент времени $t_2$ происходит аналогичная проверка вторичного критерия качества $\funcS(\m{x}, t_1, t_2)$.

Такие проверки проводятся вплоть до самого конца временного интервала наблюдений, за исключением лишь момента времени $t_n = T$.

\br

Как можно видеть, идея адаптивного алгоритма активно использует понятие <<доверительного интервала>>. Это означает, что управление не синтезируется от начала до конца, а потом применяется без каких-либо корректировок. Иными словами, ракетой не \emph{управляют}, а \emph{пытаются управлять}, и если результат далек от желаемого, вносятся определенные исправления. Эти корректировки производятся по прошествию определенного времени в том случае, если они имеют смысл: синтезированному управлению более не доверяется, строится новое, принимая за начальное состояние системы то, в котором она оказалась к текущему моменту времени. Если большого смысла в корректировках нет, и отклонения от желаемой траектории укладываются в заданные рамки, то управление считается легитимным, и ракета управляется посредством него следующий интервал времени.

Как можно видеть, такой подход не является композитным. На каждом интервале времени используется управление, полученное с помощью предыдущих двух алгоритмов. Адаптивный алгоритм определяет то, когда требуется пересчет матрицы $\m{P}(t)$, являющейся ключевым элементом синтеза, что не заложено в других методах. Иными словами, подобный подход инкапсулирует предыдущие алгоритмы.

Подобный подход полезен, когда вычисление оптимального управления на длинном интервале отнимает множество ресурсов, в том числе и временных, либо когда система сильно зашумлена. Таким образом, можно рассчитывать данные на короткие интервалы времени и корректировать поведение в соответствии желаемым результатом.

Адаптивный подход оперирует понятием вторичных критериев качества $\funcS(\emptyarg, \emptyarg, \emptyarg)$. Эти критерии должны быть тесно связаны с заданным критерием качества задачи. Они требуются в том случае, когда вычисление основного критерия отнимает слишком много времени, либо сопряжено с иными трудностями. Вторичные критерии качества $\funcS(\emptyarg, \emptyarg, \emptyarg)$ можно полагать как грубые аппроксимации самого критерия качества $\funcF(\emptyarg)$, можно выбирать некоторые эвристические характеристики,~--- все зависит от конкретного случая. От выбора $\funcS(\emptyarg, \emptyarg, \emptyarg)$ будет напрямую зависеть частота пересчета оптимальных управлений. Например, его можно выбрать следующим образом:

\beq{eq:4/2/3}
	\funcS(\m{x}, t_i, t_{i+1}) \eqdef \Biggl| \int\limits_{t_i}^{t_{i+1}} \bigl( \m{x}^T(\tau)\m{Q}(\tau)\m{x}(\tau) + ru(t)^2 \bigr)\,d\tau - 2\optF(\m{x}, t_i, t_{i+1}) \Biggr| \text{.}
\eeq

Иными словами, уравнение~\ref{eq:4/2/3} определяет абсолютную разницу между реальной динамикой зашумленной системы и ее же, но в отсутсвии каких-либо случайных внешних воздействий. Очевидно, чем больше эта разница, тем скорее необходимо корректировать управление. В силу уравнения~\vref{eq:4/1/2} получаем, что $\funcS(\m{x}, t_i, t_{i+1}) \geqslant 0$\footnote{Отметим, что хоть траектории могут отличаться, но в случае, когда $\funcS(\m{x}, t_i, t_{i+1}) = 0$, это не является существенным обстоятельством, поскольку значение критерия качества на этом интервале совпадает с оптимальным значением.}. В случае же, когда воздействий не происходит, реальная траектория не будет отличаться от оптимальной, поэтому $\funcS(\m{x}, t_i, t_{i+1}) = 0$.

Таким образом, если ввести некоторое пороговое значение $\eps > 0$, то можно определить ситуацию, когда управлению <<доверяют>>, а когда нет: в случае, если $\funcS(\m{x}, t_i, t_{i+1}) \leqslant \eps$, управлению доверяют, в противном случае требуется пересчет.

Идею вышеприведенного адаптивного метода можно выразить следующим алгоритмом:

\balgo{alg:3}
	\benum
		\item
			Делим временной интервал наблюдений $[0, T]$ на $n+1$ равную часть: $0 = t_0 \leqslant t_1 \leqslant t_2 \leqslant \ldots \leqslant t_{n} = T$, где $t_{i+1}-t_i = t_{j+1}-t_j$ для всех $i, j < n$. Интервалы типа $[t_i, t_{i+1})$ ($i<n$) назовем подынтервалами;
		
		\item
			Строим оптимальное управление $\optU$ на всем оставшемся интервале наблюдений с помощью алгоритмов~\ref{alg:1} или~\vref{alg:2};
		
		\item
			Наводим ракету с помощью управления $\optU$ на протяжении одного подынтервала времени;
		
		\item
			На открытой границе подынтервала производим расчет вторичного критерия $\funcS(\m{x}, t_i, t_{i+1})$ (например, заданного уравнением~\ref{eq:4/2/3});
			
		\item
			Если $\funcS(\m{x}, t_i, t_{i+1}) \leqslant \eps$ ($\eps > 0$), то переходим на шаг 3, в противном случае переходим на шаг 2.

	\eenum
\ealgo

\br

Покажем, что в случае незашумленной системы управление, полученное с помощью алгоритма~\ref{alg:3} будет оптимальным.

\bteo{teo:8}
    В случае, если динамическая система описывается уравнениями~\ref{eq:4/1/1} и \vref{eq:4/1/2}, а также вторичным критерием качества~\vref{eq:4/2/3}, алгоритм~\ref{alg:3} синтезирует оптимальное управление $\optU$.
\eteo

\strong{Доказательство.}

Рассмотрим критерий качества~\ref{eq:4/2/3}. Отметим, что интеграл в этом уравнении совпадает с интегральным критерием качества~\ref{eq:4/1/2}, если бы задача рассматривалась на промежутке времени $[t_i, t_{i+1}]$. В силу свойства аддитивности интегралов, уравнение~\ref{eq:4/1/2} можно представить следующим образом

\beq{eq:4/2/4}
\begin{split}
	\funcF = \frac{1}{2} \Biggl(& \int\limits_{t_0 = 0}^{t_1} \bigl( \m{x}^T(\tau)\m{Q}(\tau)\m{x}(\tau) + ru^2(t) \bigr)\,d\tau + \\
	&+ \int\limits_{t_1}^{t_2} \bigl( \m{x}^T(\tau)\m{Q}(\tau)\m{x}(\tau) + ru^2(t) \bigr)\,d\tau + \\
	&+ \cdots + \\
	&+ \int\limits_{t_{n-1}}^{t_n = T} \bigl( \m{x}^T(\tau)\m{Q}(\tau)\m{x}(\tau) + ru^2(t) \bigr)\,d\tau \Biggr) \text{.}
\end{split}
\eeq

При использовании оптимального управления $\funcF \equiv \optF$, следовательно уравнение~\ref{eq:4/2/4} можно представить в виде

\beq{eq:4/2/5}
\begin{split}
	\funcF \equiv \optF &= \frac{1}{2} \Biggl( \int\limits_{t_0 = 0}^{t_1} \bigl( \m{x}^T(\tau)\m{Q}(\tau)\m{x}(\tau) + r{\optimum{u}}^2(t) \bigr)\,d\tau + \\
	&+ \int\limits_{t_1}^{t_2} \bigl( \m{x}^T(\tau)\m{Q}(\tau)\m{x}(\tau) + r{\optimum{u}}^2(t) \bigr)\,d\tau + \\
	&+ \cdots + \\
	&+ \int\limits_{t_{n-1}}^{t_n = T} \bigl( \m{x}^T(\tau)\m{Q}(\tau)\m{x}(\tau) + r{\optimum{u}}^2(t) \bigr)\,d\tau \Biggr) = \\
	& = \frac{1}{2} \sum\limits_{i=0}^{n-1} \optF(\m{x}, t_i, t_{i+1}) = \sum\limits_{i=0}^{n-1} \frac{1}{2} \optF(\m{x}, t_i, t_{i+1}).
\end{split}
\eeq

Это справедливо в силу утверждения~\vref{statement:1}.

Таким образом, критерий качества~\ref{eq:4/1/2} является аддитивным, на каждом подынтервале времени $[t_i, t_{i+1})$ его минимальное значение при использовании оптимального управления, полученного из алгоритмов~\ref{alg:1} или~\ref{alg:2}, равно $\optF(\m{x}, t_i, t_{i+1})$.

Но из этого следует, что вторичный критерий качества, определяемый уравнением~\ref{eq:4/2/3} будет всегда равняться нулю, а значит, что $\funcS(\m{x}, t_i, t_{i+1}) < \eps$ для любого наперед заданного $\eps > 0$. Следовательно, 4 шаг алгоритма~\ref{alg:3} будет приводить к тому, что управление никогда не будет пересчитываться, а значит оно будет ровно тем же, что и при использовании алгоритмов~\ref{alg:1} или~\ref{alg:2}, а, следовательно, оптимальным. \qed

Стоит отметить, что алгоритм~\ref{alg:3} является в некотором смысле эвристическим, поскольку эффективность подобных перерасчетов в общем случае крайне сложно изучить. С другой стороны, в результате большого количества численных экспериментов с наиболее типовыми функциями, не удалось найти систему, когда такой подход давал бы худшие результаты, нежели алгоритмы~\ref{alg:1} и~\ref{alg:2}, даже наоборот: в системах с большими шумами он, с поправкой на погрешность численных методов, дает меньшее отклонение от значения оптимального критерия качества детерменированного случая.

Также следует обратить внимание на то, что алгоритм~\ref{alg:3} с вторичным критерием качества~\ref{eq:4/2/3} имеет гораздо более высокие требования к вычислительным устройствам, поскольку помимо расчета оптимального управления, требуется всякий раз рассчитывать значения двух интегралов. С другой стороны, эти задачи независимы друг от друга и прекрасно могут быть распараллелены, что при наличии двух и более процессоров приводит к сравнимому быстродействию. Впрочем, следует отметить и тот факт, что алгоритм 3 с таким вторичным критерием качества использует почти в два раза большее количество оперативной памяти для своей работы. Впрочем, в случае системы со слабой зашумленностью (или даже в полностью детерменированном случае), никакого существенного изменения в требованиях к ее количеству не происходит.

\br

Обратим внимание на то, что модфицирование алгоритма~\vref{alg:3} с целью разного рода оптимизаций, может привести к неожиданным нежелательным результатам. Рассмотрим следующую модификацию этого алгоритма:

\balgo{alg:4}
	\benum
		\item
			Делим временной интервал наблюдений $[0, T]$ на $n+1$ равную часть: $0 = t_0 \leqslant t_1 \leqslant t_2 \leqslant \ldots \leqslant t_{n} = T$, где $t_{i+1}-t_i = t_{j+1}-t_j$ для всех $i, j < n$. Интервалы типа $[t_i, t_{i+1})$ ($i<n$) назовем подынтервалами. Оптимальное управление строится поподынтервально;
		
		\item
			Строим оптимальное управление $\optU$ только лишь на следующем подынтервале с помощью алгоритмов~\ref{alg:1} или~\vref{alg:2};
		
		\item
			Наводим ракету с помощью управления $\optU$ на протяжении одного подынтервала времени;
		
		\item
			На открытой границе подынтервала производим расчет вторичного критерия $\funcS(\m{x}, t_i, t_{i+1})$ (например, заданного уравнением~\ref{eq:4/2/3});
			
		\item
			Если $\funcS(\m{x}, t_i, t_{i+1}) > \eps$ ($\eps > 0$), то сразу переходим на шаг 2. В противном случае, также переходим на шаг 2, но в качестве следующего подынтервала рассматриваем интервал удвоенной длины, если оставшихся подынтервалов достаточно (если нет~--- берется оставшийся временной промежуток). Иными следующим подынтервалом будет не $[t_{i+1}, t_{i+2})$, а $[t_{i+1}, t_{i+3})$.
	\eenum
\ealgo

Для алгоритма~\ref{alg:4} можно сформулировать теорему, аналогичную теореме~\ref{teo:8}.

\bteo{teo:9}
    В случае, если динамическая система описывается уравнениями~\ref{eq:4/1/1} и \vref{eq:4/1/2}, а также вторичным критерием качества~\vref{eq:4/2/3}, алгоритм~\ref{alg:4} синтезирует оптимальное управление $\optU$.
\eteo

Доказательство теоремы совершенно аналогично доказательству теоремы~\ref{teo:8}.

Однако, алгоритм~\ref{alg:4} совершенно не подходит к задаче управления ракетой в случае даже малого влияния шума. Более подробно этот вопрос будет исследован в разделе 4.4.



% **********************************************************************************************
\section{Программная реализация решения}
% **********************************************************************************************



Для численного моделирования и исследования задачи управления ракетой был разработан программный комплекс. Основная программа реализована на языке программирования Java, для запуска в различных режимах используется набор shell-скриптов. Для анализа полученных данных использовались утилиты \code{sed} и \code{awk}, для построения графиков~--- \code{gnuplot}.

Сборка проекта осуществляется с помощью утилиты \code{ant}, для компиляции программа использует \code{sun-java6-jdk} или \code{openjdk-java6-jdk} старше версии 1.5, запуск, соотвественно, осуществляется с помощью \code{sun-java6-jre} или \code{sun-java6-jre}. Как система контроля версий использовалась \code{git}.

Программный комплекс разрабатывался для UNIX-подобных операционных систем. В частности, работоспособность была проверена и оттестирована на Ubuntu Linux 10.10, Arch Linux, OpenSuSe 11.4 и Illumos onnv\_145. Программный комплекс с некоторыми ограничениями может работать и в операционных системах семейства Windows (требуется замена специфичных для UNIX утилит, изменения в Java-коде не требуются).

В связи с тем, что специфика работы с такими вспомогательными утилитами, как \code{sed}, \code{awk} и \code{gnuplot}, выходит за рамки этой работы, рассмотришь лишь работу с непосредственным вычислительным модулем, написанным на Java.

\br

Программный код расположен на хостинге GitHub. Для того, чтобы скопировать его себе, достаточно установить систему контроля версий \code{git}\footnote{\code{git} можно свободно скачать с \code{http://git-scm.com}.}, перейти в директорию, куда требуется загрузить исходные коды и выполнить следующую команду

\cli{git clone http://github.com/9seconds/rocketsim.git}

После выполнения этой команды в текущей директории появится директория \code{rocketsim}. Непосредственно код хранится в директории \code{./rocketsim/src}. Для того, чтобы собрать проект, необходимо перейти в директорию \code{./rocketsim} и запустить утилиту \code{ant} (можно запустить ее как \code{ant build.xml}). После компиляции, в директории появится файл \code{app.jar}, который и является конечным рабочим модулем. Дальнейшая работа с программой проводится через скрипт \code{run.sh}, либо непосредственно через запуск \code{app.jar}.

\br

Разработанный программный модуль позволяет моделировать и исследовать задачу~\ref{eq:4/1/1}--\vref{eq:4/1/2} в случае детерминированной системы и задачу~\vref{eq:4/1/14} с критерием качества~\ref{eq:4/1/2} в случае стохастической системы. Также модуль позволяет использовать все рассмотренные в предыдущем подразделе алгоритмы решения задачи.

\newpage

Рассмотрим работу с конечным вычислительным модулем. Модуль запускается со следующими ключами:

\cli{java -jar app.jar [--noise|normal] [--classic|static|extended|extendedfalse] [-k1~num] [-k2~num] [-r~num] [-d~num] [-t~num] [-v~num] [-x1~num] [-x2~num] [-x3~num] (--help)}

Разберем ключи, требуемые для запуска, подробнее.

\begin{description}
	\item[\code{--noise|normal}]
		Указывает на наличие шума в системах.
		
		Иными словами, позволяет выбрать, с какой задачей работать. Система~\ref{eq:4/1/1} включается с помощью ключа \code{--noise}, система~\ref{eq:4/1/14}~--- с помощью ключа \code{--normal}. Уровень шума устанавливается ключом \code{-v}.
		
	\item[\code{--classic|static|extended|extendedfalse}]
		Указывает алгоритм, с которым будет работать вычислительный модуль.
		
		Алгоритм~\vref{alg:1} включается с помощью ключа \code{--classic}, алгоритм~\vref{alg:2}~--- с помощью ключа \code{--static}, алгоритм~\vref{alg:3}~--- с помощью ключа \code{--extended}, алгоритм~\vref{alg:4}~--- с помощью ключа \code{--extendedfalse}.
	
	\item[\code{-k1~num}]
		Устанавливает значение величины $k_1$ в системах~\ref{eq:4/1/1} или~\ref{eq:4/1/14}.
		
		Значение выставляется с помощью обязательного численного параметра \code{num}. Например, \code{-k1~10} устанавливает значение $k_1$ в $10$.
		
	\item[\code{-k2~num}]
		Устанавливает значение величины $k_2$ в системах~\ref{eq:4/1/1} или~\ref{eq:4/1/14}.
		
		Значение выставляется с помощью обязательного численного параметра \code{num}. Например, \code{-k2~10} устанавливает значение $k_2$ в $10$.
		
	\item[\code{-r~num}]
		Устанавливает значение величины $r$ в критерии качества~\ref{eq:4/1/2}.
		
		Значение выставляется с помощью обязательного численного параметра \code{num}. Например, \code{-r~10} устанавливает значение $r$ в $10$.
		
	\item[\code{-d~num}]
		Устанавливает значение величины разбиений временного интервала.
		
		Стоит отметить, что это значение не имеет ничего общего с параметром $n$, используемом в алгоритмах. Эта величина требуется для работы численных методов интегрирования и является шагом работы метода. Меньшее значение величины позволяет получить меньшую погрешность аппроксимации системы.
		
		Значение выставляется с помощью обязательного численного параметра \code{num}. Например, \code{-d~0.0002} устанавливает величину разбиений в $0.0002$.
		
	\item[\code{-t~num}]
		Устанавливает величину временного интервала наблюдений.
		
		В описании алгоритмов и моделей эта величина значится как $T$ и, соответственно, определяет интервал $[0,T]$.
		
		Значение выставляется с помощью обязательного численного параметра \code{num}. Например, \code{-t~300} устанавливает значение $T$ в $300$.
		
	\item[\code{-v~num}]
		Устанавливает силу шума в системе~\ref{eq:4/1/14}.
		
		Если сила шума указана в детерминированной системе, выставленной ключом \code{--normal}, то это значение игнорируется. Значение, соответствующее среднему атмосферному воздействию находится в диапазоне $2E3$--$1E4$.
		
		Значение выставляется с помощью обязательного численного параметра \code{num}. Например, \code{-v~5000} устанавливает силу шума в $5000$.
		
	\item[\code{-x1~num}]
		Устанавливает начальное боковое отклонение от номинальной траектории.
		
		В системах~\ref{eq:4/1/1} и~\ref{eq:4/1/14} это значение интерпретируется как $x_1(0)$. Величина задается в метрах.
		
		Значение выставляется с помощью обязательного численного параметра \code{num}. Например, \code{-x1~1000} устанавливает $x_1(0)$ в $1000$ метров.
		
	\item[\code{-x2~num}]
		Устанавливает скорость бокового отклонения от номинальной траектории.
		
		В системах~\ref{eq:4/1/1} и~\ref{eq:4/1/14} это значение интерпретируется как $x_2(0)$. Величина задается в м/сек.
		
		Значение выставляется с помощью обязательного численного параметра \code{num}. Например, \code{-x2~300} устанавливает $x_2(0)$ в $300$ м/сек.
		
	\item[\code{-x3~num}]
		Устанавливает угол направления вектора тяги.
		
		В системах~\ref{eq:4/1/1} и~\ref{eq:4/1/14} это значение интерпретируется как $x_3(0)$. Величина задается в радианах.
		
		Значение выставляется с помощью обязательного численного параметра \code{num}. Например, \code{-x3~20} устанавливает $x_3(0)$ в $20$ радиан.
		
	\item[\code{--help}]
		Печатает эту справку.
		
		После печати справки программа завершает свою работу. Является необязательным ключом, однако если он указан, то остальные ключи игнорируются.
\end{description}

После завершения обсчетов, программа выдает результаты в стандартный поток вывода в следующем виде:

\cli{t	x1(t)	x2(t)	x3(t)}

Иными словами, в поток выдается таблица, где с каждым моментом времени $t$ связываются соответствующие значения состояний $x_1(t)$, $x_2(t)$ и $x_3(t)$. Поток можно перенаправить в отдельный файл, после чего туда запишутся результаты работы программы. Дальнейшая обработка (например, построение графиков или использование методов статистического анализа) производится уже с этим файлом.

Типичный вывод программы выглядит следующим образом:

\cli{\small
...                                                                 \\
71.851	126969.2420652556	-1111.7647506790954	-1.5296384058186148 \\
71.852	126968.13027100071	-1111.8237586095936	-1.5295579228912886 \\
71.853	126967.01841773934	-1111.8827636779565	-1.5294774407683116 \\
71.854	126965.90650547433	-1111.9417658841917	-1.5293969594498076 \\
71.855	126964.79453420853	-1112.0007652283066	-1.5293164789359002 \\
71.856	126963.68250394482	-1112.0597617103087	-1.529235999226713  \\
71.857	126962.57041468605	-1112.1187553302059	-1.5291555203223697 \\
71.858	126961.4582664351	-1112.1777460880053	-1.529075042222994  \\
71.859	126960.34605919482	-1112.2367339837144	-1.528994564928709  \\
...
}

Таким образом, типичное использование программы выглядит следующим образом:

\cli{java -jar app.jar --noise --classic -k1~9380 -k2~315 -r~10 -d~0.0025 -t~250 -v~8E3 -x1~3000 -x2~800 -x3~12 1> results.cvs}

Запущенная подобным образом программа моделирует работу системы~\vref{eq:4/1/14} по~\ref{alg:1} алгоритму с $k_1=9380$, $k_2=315$, $r=10$, степенью дискретизации численных методов $0.0025$, на интервале времени $[0, 250]$ сек., силой шума $8000$ и начальными условиями $x_1(0)=3000$ м., $x_2(0)=800$ м/сек и $x_3(0)=12$ рад. Результаты будут выведены в файл \code{results.cvs}, возможные ошибки (неправильные условия, нехватка памяти и прочие)~--- в консоль.



% **********************************************************************************************
\section{Результаты решения задачи}
% **********************************************************************************************



Рассмотрим задачу~\vref{eq:4/1/1} с критерием качества~\vref{eq:4/1/2}. Предположим для определенности, что $k_1=9380$, $k_2=315$, $x_1(0)=915$ м., $x_2(0)=244$ м/сек., $x_3(0)=0.012$ рад. Пусть также $r=10$, $T=250$, а матрица $\m{Q}(t)$ имеет следующий вид:

\beq{eq:4/4/1}
	\m{Q}(t) = \frac{1}{(300-t)^2} \matr{
		5 \emptyarg 10^{-7} & 0       & 0    \\
		0                   & 10^{-3} & 0    \\
		0                   & 0       & 10^3 \\
	} \text{.}
\eeq

Матрицы $\m{A}$ и $\m{B} = \m{b}$ определяются, как и ранее, уравнениями~\ref{eq:4/1/3} и~\vref{eq:4/1/4} соотвественно.

Таким образом, для того, матричное уравнение~\vref{eq:2/2/7} сводится к следующей системе нелинейных дифференциальных уравнений

\beq{eq:4/4/2}
	\eqsystem{
		\dot{p}_{11}(t) &= \frac{\mathstrut 1}{10}p^2_{13}(t) - \frac{5 \cdot 10^{-7}}{(300-t)^2}         \text{,} \\
		\dot{p}_{12}(t) &= \frac{1}{10}p_{13}(t)p_{23}(t) - p_{11}(t)                                     \text{,} \\
		\dot{p}_{13}(t) &= \frac{1}{10}p_{13}(t)p_{33}(t) - \frac{k_1}{k_2-t} p_{12}(t)                   \text{,} \\
		\dot{p}_{21}(t) &= 0                                                                              \text{,} \\
		\dot{p}_{22}(t) &= \frac{1}{10}p^2_{23}(t) - 2p_{12}(t) - \frac{10^{-3}}{(300-t)^2}               \text{,} \\
		\dot{p}_{23}(t) &= \frac{1}{10}p_{23}(t)p_{33}(t) - \frac{k_1}{k_2-t}p_{22}(t) - p_{13}(t)        \text{,} \\
		\dot{p}_{31}(t) &= 0                                                                              \text{,} \\
		\dot{p}_{32}(t) &= 0                                                                              \text{,} \\
		\dot{p}_{33}(t) &= \frac{1}{10}p^2_{33}(t) - 2\frac{k_1}{k_2-t}p_{23}(t) - \frac{10^3}{(300-t)^2} \text{,}
	}
\eeq

с граничными условиями в точке $\m{P}(t) = \m{0}$.

Для решения системы~\ref{eq:4/4/2} в программе реализован рассчет траекторий с помощью метода Рунге--Кутты четвертого порядка. Как было показано, оптимальное управление может быть построено по формуле~\vref{eq:4/1/7}.

\addfigure{fig:1}{p}{Оптимальные функции усиления обратной связи для системы~\ref{eq:4/4/2}.}

Численное решение системы~\ref{eq:4/4/2} изображено на графике~\ref{fig:1}. На графике\footnote{Здесь и далее под обозначением $\alpha(x) \times 10^n$ понимается масштаб функции $\alpha(x)$. Например, обозначение $p_{33}(t) \times 10$, приведенное на графике~\ref{fig:1} означает, что функция $p_{33}(t)$ смасштабирована в соотношении $10:1$.} изображены лишь функции $p_{13}(t)$, $p_{23}(t)$ и $p_{33}(t)$, то есть только те, которые, как следует из формулы~\ref{eq:4/1/7}, непосредственно требуются для построения оптимального управления.

Отметим, что эти функции задают достаточно сложное управление.

\addfigure{fig:2}{x_adaptive_normal_nonscaled}{Немасштабированные траектории системы~\ref{eq:4/1/1} при использовании алгоритма~\ref{alg:1}.}

Рассмотрим алгоритм~\vref{alg:1}. Используя решение системы~\ref{eq:4/4/2} и оптимальное управление~\ref{eq:4/1/7}, получим траектории, графически изображенные на рисунке~\ref{fig:2}. Отметим, что сравнение немасштабированных траекторий достаточно затруднено, поскольку $x_1(t) \gg x_2(t), x_3(t)$. В дальнейшем будут использоваться лишь варианты графиков с масштабированными траекториями.

\addfigure{fig:3}{x_adaptive_normal}{Масштабированные траектории системы~\ref{eq:4/1/1} при использовании алгоритма~\ref{alg:1}.}

Решение системы~\ref{eq:4/4/2} в соответствующих масштабах, наиболее удобных для восприятия, приведено на графике~\ref{fig:3}.

\br

Рассмотрим харакетр наведения ракеты на номинальную траекторию, интерпретируемую как $0$. Задача наведения ракеты заключается в том, чтобы при минимуме критерия качества~\ref{eq:4/1/2}, перевести состояние $x_1(0)$ в $x_1(T)=0$. Квадратичный критерий качества подразумевает тот факт, что одного лишь пересечения графика функции $x_1(t)$ с осью абсцисс недостаточно, требуется мягкий вход на траекторию, который позволяет избежать скорого увода ракеты. Этого, конечно, можно добиться с помощью условий $\dot{x}(T)=0$ и $\ddot{x}(T) \sim 0$, однако вычисление производных старшего порядка~--- крайне накладная вычислительная операция; схожего эффекта\cite{XU} можно добиться с помощью квадратичного критерия качества~\ref{eq:4/1/2}.

Отметим, что сначала $x_1(t)$ возрастает, достигает точки максимума, а затем убывает до $x_1(T)=0$. Это можно объяснить следующими физическими соображениями: так как скорость отклонения ракеты достаточно высока, ракета инерционна вследствие большой собственной массы и массы топлива, а управлять разрешается лишь углом направления вектора тяги, то для того, чтобы она сменила свой курс нужно некоторое время. Более того, некоторое время сила инерции будет оказывает куда более значительное влияние, чем сила, создаваемая тягой. Более того, после смены направления полета в сторону номинальной траектории, требуется очень аккуратное управление, чтобы выйти к ней по касательной, а не просто пересечь. На все это необходимо время.

Отметим, что построенное оптимальное управление достаточно плавно, без резких и сильных скачков меняет направление вектора тяги, скорость отклонение вследствие этого меняется тоже достаточно плавно.

В рамках принятой математической модели можно добиться того, чтобы наведение на траекторию было бы более быстрым, для этого нужно взять достаточно малым начальное условие $x_2(0)$. Однако в реальных системах для того, чтобы ракета не упала на землю вследствие совокупности разнообразных сил, приходится поддерживать минимальный уровень скорости.

\br

Теперь обратим внимание на влияние шумов атмосферы, иначе говоря, турбулентности. Рассмотрим модель~\ref{eq:4/1/14} и применим для синтеза оптимального регулятора алгоритм~\ref{alg:1} при принятых предположениях и начальных условиях. Траектории системы в этом случае изображены на графике~\ref{fig:4}.

\addfigure{fig:4}{x_adaptive_noise}{Траектории системы~\ref{eq:4/1/14} при использовании алгоритма~\ref{alg:1} в условиях низкой турбулентности атмосферы.}

Как можно видеть из графика, оптимальное управление и его физический смысл остались прежними: вектор тяги изменяется без резких и сильных толчков и отклонений, достаточно плавно. Однако вследствие действия силы ветра и прочих турбулентных шумов, скорость отклонения от номинальной траектории постоянно изменяется. При малых шумах это почти незаметно, однако уже при довольно сильной зашумленности (график~\ref{fig:5}), отклонения ракеты от номинальной траектории становятся намного более сильными.

\addfigure{fig:5}{x_adaptive_noise_high}{Траектории системы~\ref{eq:4/1/14} при использовании алгоритма~\ref{alg:1} в условиях сильной турбулентности атмосферы.}

Как видно из графиков~\ref{fig:4} и~\ref{fig:5}, даже в случае пересечения функцией $x_1(t)$ оси абсцисс (что означает выход на номинальный уровень), ракета все еще продолжает наводится на него, чтобы обеспечить именно <<вход>> на траекторию, а не одно лишь <<наведение>>. Еще раз отметим, что это достигается благодаря используемому критерю качества~\vref{eq:4/1/2}, который заменяет собой оба условия $\dot{x}(T)=0$ и $\ddot{x}(T) \sim 0$, является более <<легким>> с точки зрения сложности вычислений.

Более того, как видно из графика~\ref{fig:5}, оптимальное управление неявно учитывает тренд изменения скорости отклонения от номинальной тяги $x_2(t)$, и подстраивает управление соответствующим образом.

\br

Рассмотрим теперь синтез оптимального регулятора с помощью алгоритма~\vref{alg:2}. Для того, чтобы построить такой регулятор, нужно найти предельные соотношения $\lim\limits_{t \to \infty} \m{A}(t)$, $\lim\limits_{t \to \infty} \m{B}(t)$ и $\lim\limits_{t \to \infty} \m{Q}(t)$, после чего решить нелинейное матричное уравнение Риккати~\vref{eq:2/2/10}. Это достаточно сложная задача, однако в рассматриваемом частном случае сделать это достаточно просто.

Сначала найдем предельные соотношения для матриц $\m{A}(t)$, $\m{B}(t)$ и $\m{Q}(t)$:

\beqarr
	\lbl{eq:4/4/3}
		\lim\limits_{t \to \infty}\m{A}(t) = \matr{
			0 & 1 & 0 \\
			0 & 0 & \lim\limits_{t \to \infty}\frac{k_1}{k_2-t} \\
			0 & 0 & 0		
		} = \matr{
			0 & 1 & 0 \\
			0 & 0 & 0 \\
			0 & 0 & 0
		} \text{;} \\
	\lbl{eq:4/4/4}
		\lim\limits_{t \to \infty}\m{B}(t) = \m{b} = \matr{
			0 \\ 0 \\ 1		
		} \text{;} \\
	\lbl{eq:4/4/5}
		\lim\limits_{t \to \infty}\m{Q}(t) = \lim\limits_{t \to \infty}\frac{1}{(300-t)^2} \matr{
			5 \emptyarg 10^{-7} & 0       & 0    \\
			0                   & 10^{-3} & 0    \\
			0                   & 0       & 10^3 \\
		} = \m{0} \text{.}
\eeqarr

Подставляя~\ref{eq:4/4/3},~\ref{eq:4/4/4} и~\ref{eq:4/4/5} в уравнение~\ref{eq:2/2/10}, производя ряд очевидных преобразований, получим следующее матричное уравнение для коэффициентов матрицы $\m{P}$:

\beq{eq:4/4/6}
	-\frac{p_{33}}{r} \matr{
		p_{11} & p_{21} & p_{31} \\	
		p_{12} & p_{22} & p_{32} \\
		p_{13} & p_{22} & p_{33}
	} + \matr{
		0      & p_{11}          & 0      \\
		p_{11} & p_{12} + p_{21} & p_{31} \\
		0      & p_{13}          & 0
	} = \m{0} \text{.}
\eeq

Это уравнение, очевидно, справедливо при $p_{11}=0$, $p_{13}=0$, $p_{31}=0$, $p_{33}=0$, $p_{12} = -p_{21}$ и произвольных $p_{22}$, $p_{23}$ и $p_{32}$. Отсюда следует, что следующая матрица $\m{P}$ будет являться решением соответствующего матричного уравнения, а, следовательно, и искомой:

\beq{eq:4/4/7}
	\m{P} = \matr{
		0 & -1 & 0 \\
		1 & 1  & 1 \\
		0 & 1  & 0	
	} \text{.}
\eeq

Таким образом, оптимальное управление~\vref{eq:4/2/2} в силу~\ref{eq:4/4/7} примет вид

\beq{eq:4/4/8}
	\optU(t) = -\frac{x_2(t)}{r} \text{.}
\eeq

Траектории системы~\ref{eq:4/1/1} при использовании алгоритма~\ref{alg:2} и оптимального управления~\ref{eq:4/4/8} представлены на графике~\ref{fig:6}.

\addfigure{fig:6}{x_static_normal}{Траектории системы~\ref{eq:4/1/1} при использовании алгоритма~\ref{alg:2} и оптимального управления~\ref{eq:4/4/8}.}

Как нетрудно видеть, характер управления ракетой очень сильно отличается от результатов, полученных с помощью алгоритма~\ref{alg:1}. В частности, стационарное управление подразумевает, что ракета следует строго заданному курсу, управление позволяет поддерживать требуемые параметры, однако при больших отклонений от назначенной траектории, на курс она вернутся уже не сможет, следуя новому.

Отметим и сам способ управления ракетой, который заключается в том, что вектор направления тяги постоянно меняется как в сторону движения, так и против нее. Это возникает в силу предположений Калмана\cite{KALMAN1} о полной управляемости системы. Явно, конечно же, такой способ не реализуем на практике, однако существуют задачи, описываемые системами, похожими на ~\ref{eq:4/1/1} и~\ref{eq:4/1/14}, где это имеет смысл.

Стоит заметить и тот факт, что ни низкая, ни высокая турбулентность атмосферы, существенного влияния на поведение системы не оказывает: ракета строго придерживается заданного курса, что можно наблюдать на графиках~\ref{fig:7} и~\ref{fig:8}.

\addfigure{fig:7}{x_static_noise}{Траектории системы~\ref{eq:4/1/14} при использовании алгоритма~\ref{alg:2} в условиях низкой турбулентности атмосферы.}
\addfigure{fig:8}{x_static_noise_high}{Траектории системы~\ref{eq:4/1/14} при использовании алгоритма~\ref{alg:2} в условиях высокой турбулентности атмосферы.}

\br

Рассмотрим теперь алгоритм~\vref{alg:3}.

Еще раз отметим тот факт, что алгоритм~\ref{alg:3} не является принципиально новым алгоритмом, поскольку основан на сочетании предыдущих методов~\ref{alg:1} и~\ref{alg:2}. Суть алгоритма~\ref{alg:3} заключается в специфическом адаптивном сочетании алгоритмов на границах подынтервалов и корректировке значений. Более того, как утверждается в теореме~\vref{teo:8}, при отсутствии шумов, оно будет полностью повторять оптимальное управление, построенное с помощью предыдущих алгоритмов.

Не нарушая общности, в качестве вспомогательного к алгоритму~\ref{alg:3} используется алгоритм~\ref{alg:1}. Как и следует ожидать, при отсутствии шумов, траектории полностью совпадают с теми, что изображены на графике~\vref{fig:3}. При наличии среднего уровня турбулентности, результаты почти не претерпевают изменений по сравнению с детерменированным случаем (график~\ref{fig:9}). Отметим, что уровень шума в экспериментах, которым соответствуют графики~\vref{fig:4} и~\ref{fig:9}, совпадают, что может говорить об эффективности алгоритма.

% ну да, в каком-то смысле, это наеб. но ведь должен же он где-то быть!
\addfigure{fig:9}{x_adaptive_normal}{Траектории системы~\ref{eq:4/1/14} при использовании алгоритма~\ref{alg:3}.}

Об эффективности могут говорить и результаты эксперимента с высокой турбулентностью. Уровень шума в экспериментах, которым соответствуют графики~\vref{fig:5} и~\ref{fig:10} совпадают.

\addfigure{fig:10}{x_extended_noise}{Траектории системы~\ref{eq:4/1/14} при использовании алгоритма~\ref{alg:3} в условиях высокой турбулентности атмосферы.}

Иными словами, алгоритм~\ref{alg:3} показал самую высокую эффективность в случае турбулентной атмосферы. Отметим лишь тот факт, что эффективность эта, в основном, эвристическая. К тому же для его реализации требования к вычислительному модулю ракеты существенно увеличиваются.

\br

И, наконец, рассмотрим алгоритм~\ref{alg:4} и попытаемся пояснить, почему он не является эффективным в случае даже низкой турбулентности, несмотря на то, что при отсутствии шумов, он также обеспечивает построение оптимального способа наведения ракеты на заданную траекторию, о чем утверждается в теореме~\vref{teo:9}. В качестве вспомогательного алгоритма, все так же будет использован алгоритм~\ref{alg:1}.

При том же уровне шума, что и в экспериментах, которым соответствуют графики~\ref{fig:4},~\vref{fig:7} и~\ref{fig:9}, алгоритм строит полностью неоптимальное управление. Траектории системы графически представлены на рисунке~\ref{fig:11}.

\addfigure{fig:11}{x_extended_fail}{Траектории системы~\ref{eq:4/1/14} при использовании алгоритма~\ref{alg:4} в условиях низкой турбулентности атмосферы.}

Как можно заметить, управление, построенное с помощью этого алгоритма, оказалось не только менее эффективным, чем то, которое строилось с помощью предыдущих алгоритмов, но и даже вредным: за отведенное время, ракета не только не подошла к намеченному курсу, но и отклонилась настолько, что вернуть ее на орбиту Земли практически невозможно. Объясняется это достаточно просто: суть алгоритма~\ref{alg:4} заключается в том, что за короткий промежуток времени,~--- куда более короткий, чем тот, на который рассчитаны алгоритмы~\ref{alg:1} или~\ref{alg:2},~--- он пытается навести ракету на заданный курс. Если это не удается, то ракета пытаются навести за следующий промежуток. Однако, из предыдущих рассмотрений очевидно, что подобный подход обречен на провал ввиду высокой инертности тела как такового вследствие больших массы и скорости. Иными словами, попытка резкого наведения, когда ускорение ракеты все еще положительно, приводит к тому, что в следующий промежуток управление строится из того расчета, что отклонение ракеты сильно увеличилось. И всякий раз, вместо того, чтобы погасить это ускорение, производятся резкие <<тычки>>, оказывающие слабое влияние на поведение тела.

Алгоритм~\ref{alg:4} несмотря на кажущуюся безрезультатность, неперспективность и даже глупость, имеет в своей основе всего один фундаментальный недостаток, который можно сформулировать в демонстрацию сути следующего утверждения для вспомогательных алгоритмов~\ref{alg:1} и~\ref{alg:2}:

\begin{statement}\lbl{stat:2}
	Алгоритмы~\ref{alg:1} и~\ref{alg:2} неявно зависят от величины временного интервала управления $[0,T]$. В том случае, если этот интервал велик достаточно, наведение пройдет успешно; если слишком мал, то наведения не произойдет. Иными словами, каждый алгоритм имеет некоторое пороговое значение $\Theta$, которое гарантирует наведение только при выполнении условия $\Theta \geqslant T$.
\end{statement}

Экспериментально было установлено, что при всех предположениях этого раздела $\Theta_1=129,3087$, а $\Theta_2=15,0001$, где $\Theta_1$~--- пороговое значение, соответствующее алгоритму~\ref{alg:1}, а $\Theta_2$~--- алгоритму~\ref{alg:2}.

Конечно же, алгоритм~\ref{alg:4}, где длина каждого подынтервала $t_{i+1}-t_i < \Theta_1$, не может быть использован для построения оптимального управления. Этот алгоритм не является некотором вырожденным случаем: он естественным образом возникает при задаче управления на следующий за $[0,T]$ интервал времени. И в том случае, если $T<\Theta_i$ ($i=1,2$), эффективного управления с помощью приведенных алгоритмов не может быть построено в принципе, требуются новые исследования, которые приведут либо к построению новых эффективных способов построения оптимального регулятора с обратной связью, либо к доказательству теоретической невозможности подобного построения.
